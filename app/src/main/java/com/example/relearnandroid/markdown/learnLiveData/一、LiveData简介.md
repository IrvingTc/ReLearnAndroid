### 一、LiveData简介
#### 1. LiveData是什么，能干什么
- `LiveData`是`Google`推出的一个`JetPack`组件,通过**一对多**的**发布-订阅模式**，可以从`ViewModel`、单例等`唯一可信源`完成**数据的一对多分发**。

#### 2. LiveData的目标(为了解决什么问题)
- 在`LifeCycle`的帮助下，实现生命周期管理的一致性，以及作用域的可控。

- 职责非常克制：仅限于让事件源注入状态、让订阅者观察状态，乃至于还需“单例”的配合 方能正常使用 —— 从而让新手老手 都能自然而然地遵循 从**唯一可信源取材、完成状态的正确分发**—— 这样一种 得以将不可预期的错误降到最少 的状态管理理念。

- 就算不用 `DataBinding`，也能使 “单向依赖” 成为可能。

#### 3. 没有LiveData之前我们是怎么进行数据的分发的，会出现哪些问题？
- 通过各种`BUS`，如`EventBus`，在数据层或者其他地方通过`EventBus`直接发送数据，然后在每个需要数据的界面观察订阅。
可能会出现的问题：

1. 在每个界面、在特定的生命周期节点中手动的注册和解绑`EventBus`，这样使得因为疏忽导致的编码不一致而带来错误的概率大大提升。
2. 在缺乏理念约束的情况下，随意使用`EventBus`，将难以追踪真正的事件源。
3. 在缺乏理念约束的情况下，通过 `EventBus` 从页面发送通知，难以总是确保消息的正确性 和 可靠性 —— 也许当前页面的信息是过时的呢？那么所有收到通知的页面，拿到的状态也就过时了，这非常影响用户体验。

#### 4. LiveData为什么可以解决这些问题。
   - `Livedata`被设计为仅限于负责**状态在订阅者生命周期内**的分发，因此除了**setValue/postValue**，以及`observe`方法，再也没有其他方法了，**正是因为如此纯粹，所以我们不得不借助ViewModel或者单例，来完成跨层(从数据层到展示层)的状态分发**。而一旦这样做了，就完成了两个目标：

1. 一个是单向依赖：`UI -> ViewModel -> Data`
2. 从唯一可信源取材，完成状态分发。唯一可信源，意味着，**无论是哪个页面发起的对改变状态的请求，最终所有页面的状态的改变，都来自一个确定的、唯一的事件源**。

- 最后一个特点，就是**在LifeCycle的帮助下，实现编码的一致性，和可控的作用域**。

1. 可控的作用域是啥？注意`observe`方法，第一个参数就是`LifecycleOwner`，这样设计，可以让该`LifecycleOwner`（例如当前`Fragment`实例）仅在`onResume`、`onPause`等生命周期节点内，能够接收来自该`LiveData`的状态分发。从而 有效避免了当 当前页面已被 `Destory`，页面的视图仍在 `observe` 回调中被调用从而空指针异常。同时又不影响被多个 `Fragment` 共享的 `ViewModel` 所持有的该 `LiveData` 对其他 `Fragment` 的分发。
2. 也即，这里所谓的**作用域可控**, 实际上是自动地注册或解绑对事件源的监听。无需开发者手动编写，从而避免的因疏忽而造成的不必要的错误。